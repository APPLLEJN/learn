1. null和undefined的区别。
目前一般大家都会说，null表示此处没有值，undefined表示此处应该有值，但是现在还没有被赋值。其实这样说很抽象，我们更加关注的可能是在实际的使用场景中二者适用的情况。比如说：null，一般在函数参数传参为空用来占位，undefined就是未定义的值。
而null在js中属于比较特殊的值，它其实也跟js的发展历史有关，它会表现为object，是js的一个历史bug。
JS类型值是存在32 BIT 单元里，32位有1-3位表示TYPE TAG，其它位表示真实值，而object和null的低三位都是0，所以使null最终体现的类型还是object，这也就是为什么Number(null) === 0，曾经有提案 typeof null === 'null'，但提案被拒绝了。

2. js有几种数据类型，如何判断数据类型。
在ES6以前，存在5中基本类型和一种引用类型，ES6新增了Symbol类型。判断数据类型的方式比较多，不同的场景可能适用不同的方法，比如typeof用来判断基本类型，instanceOf判断引用类型，isNaN判断是不是数字，Array.isArray判断数组，但是更加准确的可能适用Object.prototype.toString。
Number.isNaN用来判断值是不是NaN，而全局的isNaN则用来判断它不是一个Number，只要它不是Number就会返回true
isNaN(NaN); // true
isNaN('A String'); // true
isNaN(undefined); // true
isNaN({}); // true
Number.isNaN(NaN); // true
Number.isNaN('A String'); // false
Number.isNaN(undefined); // false
Number.isNaN({}); // false

3. js执行机制
js代码能够运行主要依赖两个部分，第一个部分是对js代码进行编译执行，完成内存分配和垃圾回收工作的js引擎。第二部分是为js本身提供一些对象和机制，使之与其宿主能够拥有交互能力如我们常见的ajax交互。
而js引擎最重要的两部分是，内存堆和调用栈。内存堆用来存储函数及其变量，调用栈即执行上下文栈，控制代码的执行顺序，而其执行上下文则决定 this 的指向、变量对象，作用域链。
执行上下文分为两部分，创建阶段和执行阶段，而this绑定则是在执行上下文创建阶段实现的。

4. var let const 的不同， 暂时性死区是什么
1.不会被提升
2.重复声明报错
3.不绑定全局作用域
临时死区(Temporal Dead Zone)，简写为 TDZ。
let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错：

console.log(typeof value); // Uncaught ReferenceError: value is not defined
let value = 1;
这是因为 JavaScript 引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部(遇到 var 声明)，要么将声明放在 TDZ 中(遇到 let 和 const 声明)。
访问 TDZ 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 TDZ 中移出，然后方可访问。

5. 你对原型链的理解
js中的原型链是为了实现继承而产生的，在js中每个函数都拥有prototype属性，每个对象都拥有__proto__属性,二者皆指向同一个对象，并继承其属性和方法，通过一层一层的向上查找， 直到找到null，原型链结束。
关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：
继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。
6. 你对闭包的理解
MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。那什么是自由变量呢？自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。
由此，我们可以看出闭包共有两部分组成：闭包 = 函数 + 函数能够访问的自由变量
7. 你对执行上下文及执行上下文栈的理解
我理解所谓执行上下文就是一段代码执行前的一些准备工作，就是我们出去旅行，要提前准备行李，牙具等，代码的执行需要提前准备this、
变量对象、作用域链。
8. 你知道的requestAnimationFrame
简单来说，requestAnimationFrame就是为了使用js能方便的实现流畅动画的API。我们知道动画是由浏览器按照一定的频率一帧一帧的绘制的，由css实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新UI，给用户一种流畅的体验，而setInterval或setTimeout实现的JavaScript动画就没有这么可靠了，因为浏览器压根就无法保证每一帧渲染的时间间隔，一般情况下，每秒平均刷新次数能够达到60帧，就能够给人流畅的体验，即每过 1000/60 毫秒渲染新一帧即可，但从上面的例子知，这一点单靠定时器是无法保证的。
为此，requestAnimationFrame应运而生，其作用就是让浏览器流畅的执行动画效果。可以将其理解为专门用来实现动画效果的api，通过这个api,可以告诉浏览器某个JavaScript代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了。
9. 什么是严格模式
按MDN的说法严格模式是采用具有限制性JavaScript变体的一种方式，从而使代码显示地 脱离“马虎模式/稀松模式/懒散模式“（sloppy）模式。
严格模式对正常的 JavaScript语义做了一些更改。
严格模式通过抛出错误来消除了一些原有静默错误。
严格模式修复了一些导致 JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。
严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。
举例来说：严格模式下，变量都必须先用var命令声明，然后再使用。严格模式下函数不能有重名的参数，禁止this关键字指向全局对象，禁止使用with语句
eval语句本身就是一个作用域，它所生成的变量只能用于eval内部。
12. AMD, CMD, commonJS，import的理解。设计一个方法，让CommonJS导出的模块也能改变其内部变量
AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。即依赖前置。
CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。
/** AMD写法 **/
define(["a", "b", "c", "d", "e", "f"], function(a, b, c, d, e, f) {
     // 等于在最前面声明并初始化了要用到的所有模块
    a.doSomething();
    if (false) {
        // 即便没用到某个模块 b，但 b 还是提前执行了
        b.doSomething()
    }
});

/** CMD写法 **/
define(function(require, exports, module) {
    var a = require('./a'); //在需要时申明
    a.doSomething();
    if (false) {
        var b = require('./b');
        b.doSomething();
    }
});
node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。
commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。
ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。
ES6 模块与 CommonJS 模块的差异
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。
CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
因为commonjs是值拷贝，所以一旦导出，里面变化对外部不会有影响。如下
```
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
// main.js
var mod = require('./lib');

console.log(mod.counter);  // 3
mod.incCounter();
console.log(mod.counter); // 3

```
可以通过导出函数的方式实现动态引用
```
var counter = 3;
function incCounter() {
    counter++;
}
module.exports = {
    get counter() {
        return counter
    },
    incCounter: incCounter,
};

```
或者ES6
```
// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
}

// main.js
import { counter, incCounter } from './lib';
console.log(counter); // 3
incCounter();
console.log(counter); // 4

```

13. async/await和promise性能差异
（https://github.com/frontend9/fe9-interview/issues/24）
回调函数，会产生回调地狱，代码混乱，不易维护。事件发布订阅，消耗内存，过度使用会使代码难以维护和理解。

Promise是es6提出的异步编程的一种解决方案。
Promise,无法取消promise。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。当执行多个Promise时，一堆then看起来也很不友好。

Generator是es6提出的另一种异步编程解决方案，需要在函数名之前加一个*号，函数内部使用yield语句。Generaotr函数会返回一个遍历器，可以进行遍历操作执行每个中断点yield。没有了Promise的一堆then(),异步操作更像同步操作，代码更加清晰，缺点是不能自动执行异步操作，需要写多个next()方法，需要配合使用Thunk函数和Co模块才能做到自动执行。

async是es2017引入的异步操作解决方案，可以理解为Generator的语法糖，async等同于Generator和co模块的封装，async 函数返回一个 Promise。内置执行器，比Generator操作更简单。async/await比*/yield语义更清晰。返回值是Promise对象，可以用then指定下一步操作。代码更整洁。可以捕获同步和异步的错误。
14. 说一说浮点数类型， 0.1 + 0.2 是否等于 0.3 ？
（https://juejin.im/post/5b90e00e6fb9a05cf9080dff）
ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。
在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。
首先，计算机无法直接对十进制的数字进行运算，这是硬件物理特性已经决定的。这样运算就分成了两个部分：先按照IEEE 754转成相应的二进制，然后对阶运算。
0.1和0.2转换成二进制后会无限循环，但是由于IEEE 754尾数位数限制，需要将后面多余的位截掉，这样在进制之间的转换中精度已经损失。
那为什么 x=0.1 能得到 0.1？
这是因为这个 0.1 并不是真正的0.1。这不是废话吗？别急，听我解释
标准中规定尾数f的固定长度是52位，再加上省略的一位，这53位是JS精度范围。它最大可以表示2^53(9007199254740992), 长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理


15. 讲一下js的隐式转换和强制类型转换
（https://github.com/mqyqingfeng/Blog/issues/164）
console.log(Boolean(NaN)) // false
console.log(Boolean(null)) // false

console.log(Number(undefined)) // NaN
console.log(Number(null)) // +0
如果通过 Number 转换函数传入一个字符串，它会试图将其转换成一个整数或浮点数，而且会忽略所有前导的 0，如果有一个字符不是数字，结果都会返回 NaN，鉴于这种严格的判断，我们一般还会使用更加灵活的 parseInt 和 parseFloat 进行转换。
parseInt 只解析整数，parseFloat 则可以解析整数和浮点数，如果字符串前缀是 "0x" 或者"0X"，parseInt 将其解释为十六进制数，parseInt 和 parseFloat 都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回 NaN：
console.log(parseInt("3 abc")) // 3
console.log(parseFloat("3.14 abc")) // 3.14
console.log(parseInt("-12.34")) // -12
console.log(parseInt("0xFF")) // 255
console.log(parseFloat(".1")) // 0.1
console.log(parseInt("0.1")) // 0
如果对象具有 toString 方法，则调用这个方法。如果他返回一个原始值，JavaScript 将这个值转换为字符串，并返回这个字符串结果。
如果对象没有 toString 方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf 方法。如果存在这个方法，则 JavaScript 调用它。如果返回值是原始值，JavaScript 将这个值转换为字符串，并返回这个字符串的结果。
否则，JavaScript 无法从 toString 或者 valueOf 获得一个原始值，这时它将抛出一个类型错误异常。
console.log(({}).toString()) // [object Object]
console.log([].toString()) // ""
对象转数字的过程中，JavaScript 做了同样的事情，只是它会首先尝试 valueOf 方法
如果对象具有 valueOf 方法，且返回一个原始值，则 JavaScript 将这个原始值转换为数字并返回这个数字
否则，如果对象具有 toString 方法，且返回一个原始值，则 JavaScript 将其转换并返回。
否则，JavaScript 抛出一个类型错误异常。
console.log(Number({})) // NaN
console.log(Number({a : 1})) // NaN

console.log(Number([])) // 0
console.log(Number([0])) // 0
console.log(Number([1, 2, 3])) // NaN
console.log(Number(function(){var a = 1;})) // NaN
console.log(Number(/\d+/g)) // NaN
console.log(Number(new Date(2010, 0, 1))) // 1262275200000
console.log(Number(new Error('a'))) // NaN

一元+

如果 obj 为基本类型，直接返回
否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。
否则，调用 toString 方法，如果返回一个原始值，则JavaScript 将其返回。
否则，JavaScript 抛出一个类型错误异常。

二元+
console.log(null + 1);
按照规范的步骤进行分析：

lprim = ToPrimitive(null) 因为null是基本类型，直接返回，所以 lprim = null
rprim = ToPrimitive(1) 因为 1 是基本类型，直接返回，所以 rprim = null
lprim 和 rprim 都不是字符串
返回 ToNumber(null) 和 ToNumber(1) 的运算结果

20. 解释 JavaScript 中的相等性。
如果x与y是同一类型：

x是Undefined，返回true
x是Null，返回true
x是数字：
x是NaN，返回false
y是NaN，返回false
x与y相等，返回true
x是+0，y是-0，返回true
x是-0，y是+0，返回true
返回false
x是字符串，完全相等返回true,否则返回false
x是布尔值，x和y都是true或者false，返回true，否则返回false
x和y指向同一个对象，返回true，否则返回false
x是null并且y是undefined，返回true

x是undefined并且y是null，返回true

x是数字，y是字符串，判断x == ToNumber(y)

x是字符串，y是数字，判断ToNumber(x) == y

x是布尔值，判断ToNumber(x) == y

y是布尔值，判断x ==ToNumber(y)

x不是字符串或者数字，y是对象，判断x == ToPrimitive(y)

x是对象，y不是字符串或者数字，判断ToPrimitive(x) == y
返回false

23. for..in 和 object.keys的区别
循环类型	耗费时间(ms)
for	约11.998
for cache	约10.866
for 倒序	约11.230
forEach	约400.245
for in	约2930.118
for of	约320.921
for...in遍历对象及其原型链上可枚举的属性，遍历对象时参数是key，遍历数组时是索引，某些情况下，可能按随机顺序遍历数组元素，所以它不适合遍历数组。
Object.keys，返回对象自身可枚举属性组成的数组。不会遍历对象原型链上的属性以及 Symbol 属性。
for...of不能遍历数组会出错，遍历数组时参数是值。支持遍历数组，类数组对象（DOM NodeList），字符串，Map 对象，Set 对象；
1. 能用for缓存的方法循环就用for循坏,性能最高,写起来繁杂;
2.不追求极致性能的情况下,建议使用forEach方法,干净，简单，易读，短，没有中间变量，没有成堆的分号，简单非常
优雅;
3.想尝鲜使用ES6语法的话,不考虑兼容性情况下,推荐使用for of方法,这是最简洁、最直接的遍历数组元素的语法,该方
法避开了for-in;循环的所有缺陷与forEach()不同的是，它可以正确响应break、continue和return语句.
4.能避免for in循环尽量避免,太消费性能,太费时间,数组循环不推荐使用.

21. 解析 ['1', '2', '3'].map(parseInt)
parseInt(string, radix)   将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。
24. 介绍箭头函数和普通函数的区别
按MDN说，箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。

11. 对函数式编程的理解
22. 使用canvas绘图时如何组织成通用组件



