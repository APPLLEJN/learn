（https://www.cnblogs.com/chengxs/p/11022842.html）
（https://juejin.im/entry/5b0e3eba5188251534379615）
（https://juejin.im/post/5d99a8265188254d014e364e#heading-4）
（https://zhuanlan.zhihu.com/p/58151131）
（https://yq.aliyun.com/articles/606821）
（https://imweb.io/topic/59324940b9b65af940bf58ae）
（https://imweb.io/topic/5baca58079ddc80f36592f1a）
（https://blog.didiyun.com/index.php/2019/12/06/wepack-%E9%80%8F%E8%A7%86-%E6%8F%90%E9%AB%98%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BC%89/）
#### webpack的构建原理

#### Loader和Plugin的不同？
作用不同：（1）loader让webpack有加载和解析非js的能力；（2）plugin可以扩展webpack功能，在webpack运行周期中会广播很多事件，Plugin可以监听一些事件，通过webpack的api改变结果。

用法不同：（1）loader在module.rule中配置。类型为数组，每一项都是Object；（2）plugin是单独配置的，类型为数组，每一项都是plugin实例，参数通过构造函数传入。

#### 实现一个loader和plugin

编写Loader时要遵循单一原则，每个Loader只做一种"转义"工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。

Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

#### webpack与grunt、gulp的不同？与webpack类似的工具还有哪些？

三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。

grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。

webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。

总结：（1）从构建思路来说：gulp和grunt需要开发者将整个前端构建过程拆分成多个`Task`，并合理控制所有`Task`的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工；

（2）对于知识背景：gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路。

1. webpack treeShaking原理，是靠什么才能实现(ES6模块的静态导出)

3. webpack里面的插件是怎么实现的
4. 抽取公共文件是怎么配置的
5. require.js的实现原理（如果使用过webpack，进一步会问，两者打包的异同及优缺点）

7. 谈谈你为什么最终选择（或放弃）使用webpack？有哪些常见的Loader？他们是解决什么问题的？
8. 有哪些常见的Plugin？他们是解决什么问题的？

10. webpack的构建流程是什么?
11. 从读取配置到输出文件这个过程尽量说全是否写过Loader和Plugin？
12. 描述一下编写loader或plugin的思路？
13. webpack的热更新是如何做到的？说明其原理？
14. 如何利用webpack来优化前端性能？（提高性能和体验）
用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。

（1）压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css。使用webpack4，打包项目使用production模式，会自动开启代码压缩。

（2）利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径

（3）删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现或者使用es6模块开启删除死代码。

（4）优化图片，对于小图可以使用 base64 的方式写入文件中

（5）按照路由拆分代码，实现按需加载，提取公共代码。

（6）给打包出来的文件名添加哈希，实现浏览器缓存文件
15. 如何提高webpack的构建速度？
（1）多入口的情况下，使用commonsChunkPlugin来提取公共代码；

（2）通过externals配置来提取常用库；

（3）使用happypack实现多线程加速编译；

（4）使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。原理上webpack-uglify-parallel采用多核并行压缩来提升压缩速度；

（5）使用tree-shaking和scope hoisting来剔除多余代码。
16. 怎么配置单页应用？怎么配置多页应用？
17. npm打包时需要注意哪些？
18. 如何利用webpack来更好的构建？
19. 如何在vue项目中实现按需加载？


babel
(https://cloud.tencent.com/developer/article/1520124)
(https://segmentfault.com/a/1190000013261724)
(https://github.com/frontend9/fe9-library/issues/154)
(https://zhuanlan.zhihu.com/p/27289600)